**Новый взгляд на асинхронность: в лучших традициях gevent (но по-другому!)**

Некоторые уже видели мои статьи про добавление асинхронности в django.
Этот пост не об этом: вопрос более широкий и посвящён асинхронности в целом. Да и подход совсем другой.

Кстати, вопрос с асинхронным django тоже решился - как побочный продукт. Между прочим, собираюсь использовать в продакшене при первой возможности.

Итак, асинхронность в стиле gevent - как бы это могло быть?

Сначала немного предисловия. Своего рода источником вдохновения стала sql-алхимия с её странным плагином для асинхронности. Если кто не знает, алхимия использует гринлеты в качестве мостика между синхронным и асинхронным кодом.
У меня даже состоялась [небольшая переписка](https://github.com/Bi-Coloured-Python-Rock-Snake/readme/issues/3) с Майком Байером (автором sql-алхимии), как раз по вопросу использования гринлетов в алхимии, где я выразил своё мнение, что, мол, дешёвая штука, никуда не годная, антипаттерн для учебников. Я уже был готов представить неопровержимые аргументы, но потом немного подумал... и ещё немного подумал - и решил, что в этом что-то есть.

Итак, что нам даёт хак с гринлетами: он позволяет вызывать асинхронные функции внутри синхронных. Такие скрытые асинхронные функции, получается: вызываются как обычные, а под капотом реализацию имеют асинхронную. 

Для того, чтобы этот хак работал, нужно иметь возможность разделить синхронный и асинхронный код по двум разным гринлетам (функциям). В таком случае, каждый раз, когда мы встречаем функцию с асинхронной реализацией, мы можем переключаться в асинхронный гринлет и вычислять её там. Необязательно всё это сейчас представлять, но можно запомнить простое правило:

*Мы имеем возможность вызывать (скрытые) асинхронные функции как обычные, но функция, в которой мы это делаем, сама должна быть обычной, то есть, объявленной без слова async*

Возникает вопрос, зачем нам такие извращения нужны - сейчас вы всё поймёте.

Во-первых, мы получаем своего рода gevent: мы пишем код как синхронный, под капотом же он использует асинхронный ввод-вывод. Причём, интеллигентный gevent: никакого monkey-patching-а, мы сами пишем асинхронную реализацию для нужных
функций. Если gevent берёт ваш синхронный код, как он есть, и магически превращает его в асинхронный, то в нашем случае - нет, нужно позаботиться о том, чтобы все наши библиотеки поддерживали асинхронный ввод-вывод и такой способ запуска.

Возьмём, к примеру, django. Достаточно для него написать асинхронный database backend - и вуаля, он становится асинхронным! У меня будет пример с кодом, так что сами увидите.

Во-вторых, мы можем поддержать синхронный и асинхронный ввод-вывод одновременно: это может регулироваться всего одной настройкой. И это уже - преимущество перед традиционным подходом, в asyncio Вы такого не сделаете. Для веб разработки, допустим, асинхронный ввод-вывод всегда предпочтительней, но что, если у нас какой-нибудь сервис ML, и всё, что он обычно делает - это запускает tensorflow?

Итак, как это всё выглядит на практике: вот пример с кодом. Я решил взять нетривиальную django view и сделать её асинхронной.